#! /bin/bash

# pkginfo package information report generator
# Copyright (C) 2003-2004 Oliver Brakmann <oliverbrakmann@users.berlios.de> &
# Gareth Jones <gareth_jones@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA

# Global prometheus functions.
source "%LIBPROMETHEUS%" || exit 1

# Usage: usage
# Print help text.
function usage {
	cat <<-EOF
Usage:
${0##*/} [<options>] [pkg]

Display information on installed and available software packages.

Options:
-c, --config <config_file>      Specify alternative configuration file
-v, --verbose			Be verbose, where appropriate

-a, --query-all			List all packages
-i, --query-installed		List all installed packages
-d, --dependencies <pkg>	List dependencies of packages
-p, --patches <pkg>		List patches to be applied to packages
-l, --list <pkg>		List all files installed by packages
-w, --which <file>		List package a file belongs to
--                              Treat remaining arguments as packages

-h, -?, --help                  Show this help screen
-V, --version                   Show version information
	EOF
	finish
}


# Usage: query_package
# Gather and display information about a package
function query_package {
	local date pkg_version size

	if [[ -f "${logdir}/${arg}" ]]; then
		date="not installed"
	else
		date="$(date -r "${logdir}/${arg}" "+%Y-%m-%d %H:%M (%a)")"
	fi

	[[ -n "$verbose" ]] &&
	if [[ -r "${logdir}/${arg}" ]]; then
		local i
		size=0

		for i in $(sed -e 's/# Old # //' -e '/# Del #.*/d' \
				"${logdir}/${arg}" 2> /dev/null)
		do
			[[ -e "$i" ]] &&
			size=$(( $size + $(ls -l "$i" 2> /dev/null | \
					awk -F\  '{ print $5; }' ) ))
		done
		size=$(( $size / 1024 ))
	fi

	[[ -f "$version_table" ]] &&
	if [[ "$(grep "^$arg	" "$version_table" | sed -e 's/	//')"x != x ]]
	then
		[[ ! -f "$logdir/$arg" ]] && date="orphaned entry"
		log_version="$(sed -n "s/^$arg	//p" "$version_table")"
	fi

	[[ -f "${profiles}/${arg}.pkg" ]] && source_profile "$arg"



	if [[ -n "$verbose" ]]; then
		echo
		echo "Package  : ${name:-$arg}"
		echo "Version  : ${log_version:-n/a} / ${version:-n/a}"
		[[ -n "$homepage" ]] && echo "Homepage : $homepage"
		echo "Installed: $date"
		echo -n "Size     : "
		[[ -n "$size" ]] && echo "$size kb" || echo "n/a"
		echo
	else
		printf "%-32.32s " "$arg"

		if [[ -n "$log_version" ]]; then
			 printf "%-24.24s" "$log_version"
		else
			if [[ -f "${logdir}/${arg}" ]]; then
				printf "%-24.24s" "n/a${version:+ ($version)}"
			else
				printf "%-24.24s" "$version"
			fi
		fi
		printf " %-22.22s\n" "$date"
	fi

	return 0
}


# Usage: query_installed
# Run query_package on every installed package
function query_installed {
	# All installed packages should have a corresponding log file in
	# $logdir, so we check those first.

	ls -rt "$logdir"/* 2> /dev/null | sed -e 's/.*\///' | \
	xargs -r pkginfo ${verbose:+--verbose}

	# It is theoretically possible that a package has an entry in .vtab,
	# but no corresponding log file.  This part finds those packages.
	local i

	sed -e 's/	.*//' "$logdir/.vtab" 2> /dev/null | \
	while read i; do
		[[ ! -f "$logdir/$i" ]] &&
		echo "$i"
	done | xargs -r pkginfo  ${verbose:+--verbose}
}


# Usage: query_all
# Run query_package on all packages that have `log_install=yes'
# in their .pkg profile
function query_all {
	grep -L "^[ 	]*log_install=no" "$profiles"/*.pkg 2> /dev/null | \
	sed -e '/REFERENCE/d' -e 's/.*\///' -e 's/\.pkg//' | \
	xargs pkginfo ${verbose:+--verbose}
}


# Usage: print_deps
# List dependencies of a package.
function print_deps {
	get_dependencies "$arg"

	local i
	for (( i=0; i < ${#dependencies[0]}; i++ )); do
		echo ${dependencies[$i]}
		# FIXME: Do we need verbose output?
	done
}


# Usage: print_patches
# List patches in a package's profile. (Not for stage1/2)
function print_patches {
	source_profile "$arg"

	local i
	for (( i=0; i < ${#patches[0]}; i++ )); do
		echo "$(basename $(remove_compression "${patches[$i]}"))"

		if [[ -n "$verbose" ]]; then
			local patch
			patch="$(location_of "${patches[$i]}")" &&
			[[ -n "$patch" ]] &&
			cat_file "$patch" | \
				sed '/^+++/,$d; /^---/,$d; /^diff/,$d'
		fi
	done
}


# Usage: print_files
# List all files installed by a package.
function print_files {
	[[ -f "${logdir}/${arg}" ]] || error "$arg is not installed."

	sed -e 's/# Old # //' -e '/# Del #.*/d' "${logdir}/{$arg}"
}


# Usage: find_owner
# Find the package that a file belongs to.
function find_owner {
	if [[ "${arg:0:1}" != / ]]; then
		# $arg is not an absolute pathname. Prepend PWD and
		# strip out any bla/../'s and ./'s
		arg="$(echo $(pwd)/$arg | sed -e 's@[^/]*/\.\./@@g' -e 's@\./@@g')"
	fi

	[[ -e "$arg" ]] || error "\"$arg\" does not exist."

	local pkg

	egrep -l "(^# Old # |^)$arg$" "$logdir"/* 2> /dev/null | \
	sed -e 's@.*/\(.*\)$@\1@' | while read pkg
	do
		(( "x$verbose" == xverbose )) &&
			echo "$pkg" "$(get_installed_version "$pkg")"  ||
			echo "$pkg"
	done
}

# --------------------------- START EXECUTION HERE --------------------------- #

unset verbose query_all query_installed dependencies patches list which
unset arg_list arg

# Check for options.
while [[ "$1" == -* ]]; do
	case "$1" in
		(-c|--config)                   config="$2"
                                                shift ;;

		(--config=*)                    config="${1#--config=}" ;;

		(-v|--verbose)			verbose=verbose ;;

		(-a|--query-all)		query_all=query_all
						shift
						break ;;

		(-i|--query-installed)		query-installed=query-installed
						shift
						break ;;

		(-d|--dependencies)		dependencies=dependencies
						shift
						break ;;

		(-p|--patches)			patches=patches
						shift
						break ;;

		(-l|--list)			list=list
						shift
						break ;;

		(-w|--which)			which=which
						shift
						break ;;

		(-h|-\?|--help)                 usage ;;

		(-V|--version)                  version ;;

		(--)                            shift
						break ;;

		(*)             script_usage_err "unrecognized option: $1"
	esac
	shift
done

# Boy, the argument handling is ugly!
# Anyone come up with an idea to solve this in a clean way?

# If no option has been specified, run a simple query on every argument.
if [[ -z "${query_installed}${query_all}${dependencies}${patches}${list}${which}" ]]; then
	# The remaining arguments should all be packages.
	(( $# == 0 )) && script_usage_err "no package specified"

	# Remove duplicates from parameter list.
	arg_list=( "$@" )
	remove_dupes arg_list

	# If there is more than one argument, handle each in its own instance.
	if (( ${#arg_list[@]} > 1 )); then
        	for arg in "${arg_list[@]}"; do
                	"$0" --config="$config" "$arg"
		done
		finish
	else
		arg="$1"
	fi
fi

if [[ -n "${dependencies}${patches}${list}${which}" ]]; then
	arg="$1"
	[[ x != x"$arg" ]] || error "missing argument"
fi

source_config

if   [[ -n "$query_all"       ]]; then	query_all
elif [[ -n "$query_installed" ]]; then	query_installed
elif [[ -n "$dependencies"    ]]; then	print_deps
elif [[ -n "$patches"         ]]; then	print_patches
elif [[ -n "$list"            ]]; then	print_files
elif [[ -n "$which"           ]]; then	find_owner
else					query_package
fi

finish
