#! /bin/bash

# pkgrm package uninstaller
# Copyright (C) 2003-2004 Oliver Brakmann <oliverbrakmann@users.berlios.de> &
# Gareth Jones <gareth_jones@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA

# Global prometheus functions.
source "%LIBPROMETHEUS%" || exit 1

# Usage: usage
# Print help text.
function usage {
	cat <<-EOF
Usage:
${0##*/} [<options>] <package_list>

Remove an installed package from the system and create a backup if desired.

Options (must precede package list):
-c, --config <config_file>	Specify alternative configuration file
-f, --force			Non-interactive mode. Do not prompt
-b, --backup			Create a backup of the removed package
--				Treat remaining arguments as packages

-h, -?, --help			Show this help screen
-v, --version			Show version information

	EOF
	finish
}

# Usage: get_privileges
# Rerun as root if necessary.
function get_privileges {
	if [[ "$install_as_root" == yes ]] && (( $(id -u) != 0 )); then
		echo "You must be root to remove $name."
		exec su -c "'$0' --config='$config' ${backup:+--backup} \
			${force:+--force} $package'"
	fi
}

# Usage: do_backup
# Backup an installed package
function do_backup {

	[[ -r "${logdir}/${package_list[0]}" ]] ||
	error "cannot read ${package_list[0]} log file"

	[[ -d "$backupdir" ]] || 
	error "$backupdir does not exist"

	[[ -w "$backupdir" ]] ||
	error "$backupdir is not writable"

	# xargs -r aborts if stdin is empty.
	# tar -P does not strip leading slashes in filenames.
	# tar --ignore-failed-read ignores non-existant files.
	sed -e 's/# Old # //' -e '/# Del #.*/d' "${logdir}/${package_list[0]}" |
	xargs -r tar cjPf "${backupdir}/${package_list[0]}.bak.tar.bz2" \
		--ignore-failed-read 2> /dev/null ||
	error "backup failed"
}

# Usage: create_dep_list
# Build a list of packages that depend on our current one.
function create_dep_list {

	local pkg

	for pkg in $(pkginfo --installed 2> /dev/null | cut -f1 -d\ ); do
		if pkginfo --dependencies "$pkg" 2> /dev/null |
			grep ${package_list[0]} > /dev/null; then
			dep_list="${dep_list}\n$pkg"
		fi
	done

	return 0
}

# Usage: rm_empty_tree
# Read a list of directories from stdin and recursively remove the trees.
# Stop at the first non-empty directory.
function rm_empty_tree {

	local dir

        while read dir; do
                if rmdir "$dir" 2> /dev/null; then
                        echo "${dir%/*}" | rm_empty_tree
                fi
        done

        return 0
}

# Usage collect_dirs
# Build a list of those directories that the current pkg stored files in.
function collect_dirs {

	(( $(wc -c "${logdir}/${package_list[0]}" | cut -f1 -d\ ) > 0 )) ||
		return 1

	local dir

	# Do not remove '# Del #'eleted items from the list. Even though
	# the files may be gone, the directories might still exist.
	sed -e 's/# Old # //' -e 's/# Del # //' "${package_list[0]}" | \
	while read dir; do
		echo "${dir%/*}"
	done | sort --unique
}

# Usage: remove_files
# Remove all files that were logged during installation
function remove_files {

	# Weed out `# Old #' markings and remove lines marked `# Del #'
	sed -e 's/# Old # //' -e '/# Del #.*/d' "${logdir}/${package_list[0]}" | \
	xargs --no-run-if-empty rm -f ||
	return 1

	collect_dirs | rm_empty_tree

	return 0
}

# Usage: remove_logs
# Remove install-log log file and vtab entry
function remove_logs {

	local tmpfile=$(mktemp -t vtab.XXXXXXXXXX)

	# remove vtab entry
	sed "/^$1	/d" "$version_table" > $tmpfile &&
	mv $tmpfile "$version_table" ||
	failure "could not update $version_table"

	# remove install-log log file
	rm -f "${logdir}/${package_list[0]}" ||
	error "could not remove install-log log file"

	return 0
}

# --------------------------- START EXECUTION HERE --------------------------- #

unset backup force dep_list

# Check for options.
while [[ "$1" == -* ]]; do
	case "$1" in
		(-c|--config)			config="$2"
						shift ;;

		(--config=*)			config="${1#--config=}" ;;

		(-h|-\?|--help)			usage ;;

		(-b|--backup)			backup=backup ;;

		(-f|--force)			force=force ;;

		(-v|--version)			version ;;

		(--)				shift
						break ;;

		(*)		script_usage_err "unrecognized option: $1"
	esac
	shift
done

# The remaining arguments should all be packages.
(( $# == 0 )) && script_usage_err "no packages to remove"

# Remove duplicate packages from parameter list.
package_list=( "$@" )
remove_dupes package_list

source_config

# If there is more than one package, remove each in its own instance.
if (( ${#package_list[@]} > 1 )); then
	for package in "${package_list[@]}"; do
		"$0" --config="$config" ${backup:+--backup} \
			${force:+--force} "$package" ||
		error "removal of $package failed"
	done
	finish
fi

# There is only one package to remove.  Do so in this instance.
source_profile ${package_list[0]}

# Test whether the package is actually installed.
# This also tests whether the logfile is readable, btw.
if pkginfo ${package_list[0]} | grep --invert-match "not installed"; then
	get_privileges

	installed_version="$(get_installed_version "${package_list[0]}")"
	installed_name="$name${installed_version:+ $installed_version}"

	if [[ -z "$force" ]]; then
		create_dep_list
		if [[ -n "$dep_list" ]]; then
			echo "The following packages depend on ${package_list[0]}:"
			echo -e $dep_list | sort
			echo
		fi
		echo -n "Do you really want to remove ${package_list[0]}? [y/n] "
		choice || error "${package_list[0]} has not been removed"

		if [[ -n "$backup" ]]; then
			echo -n "Do you want to create a backup prior to \
removing ${package_list[0]}? [y/n] "
			choice && backup=backup || unset backup
		fi
	fi

	[[ -n "$backup" ]] && do_backup

	echo "Removing ${installed_name}..."
	remove_files &&
	remove_logs ||
	error "${package_list[0]} could not be removed"
else
	error "${package_list[0]} is not installed"
fi

finish
