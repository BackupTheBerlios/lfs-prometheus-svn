#! /bin/bash

# pkginstall package installer
# Copyright (C) 2003-2004 Oliver Brakmann <oliverbrakmann@users.berlios.de> &
# Gareth Jones <gareth_jones@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA

# Global prometheus functions.
source "%LIBPROMETHEUS%" || exit 1

# Usage: usage
# Print help text.
function usage {
	cat <<-EOF
Usage:
${0##*/} [<options>] <package_list>

Install packages from their build directories, in the order given on the
commandline.

Options (must precede package list):
-b, --backup-installed		Backup and remove any existing installations
-c, --config <config_file>	Specify alternative configuration file
-l, --leave-installed		Do not touch any existing installations
-L, --leave-failed		Leave files from any failed installations
-o, --overwrite-installed	Overwrite any existing installations
-r, --remove-installed		Remove any existing installations
-R, --remove-failed		Cleanup files from any failed installations
-s, --stage <stage_number>	Specify stage 0, 1 or 2 (default = 2)
--				Treat remaining arguments as packages

-h, -?, --help			Show this help screen
-V, --version			Show version information

	EOF
	finish
}

# Usage: get_privileges
# Rerun as root if necessary.
function get_privileges {
	if [[ "$install_as_root" == yes ]] && (( $(id -u) != 0 )); then
		echo "You must be root to install $name."
		exec su -c "'$0' --config='$config' --stage=$stage \
				 ${installed:+--$installed-installed} \
				 ${failed:+--$failed-failed} '$package'"
	fi
}

# Usage: add_version_entry <version>
# Update version table.
function add_version_entry {
	if (( $# != 1 )) || [[ -z "$1" ]]; then
		usage_error "add_version_entry" "<version>" "$*"
	fi

	touch "$version_table" &&
	grep --invert-match "^$package	" "$version_table" > \
	     "$version_table.$$" &&
	echo -e "$package\t$1" >> "$version_table.$$" &&
	sort -u "$version_table.$$" > "$version_table" &&
	rm "$version_table.$$" ||
	failure "updating version table \`$version_table' failed"
}

# Usage: remove_installed
# Deal with any existing installation of $package.
function remove_installed {

	# Return if not already installed.
	pkginfo "$package" | grep "not installed" > /dev/null && return

	# Get version of installed $package.
	installed_version="$(get_installed_version "$package")"
	installed_name="$name${installed_version:+ $installed_version}"

	# $installed wasn't set on the command line.  Go interactive.
	if [[ -z "$installed" ]]; then
		echo "$installed_name is already installed."
		echo -n "Abort installation? [y/n] "
		choice && installed=leave
	fi

	# User wants to continue installation.
	if [[ -z "$installed" ]]; then
		echo "Do you want to remove currently installed $installed_name"
		echo -n "prior to installation? [y/n] "
		choice && installed=remove

		# Maybe they want to backup the existing installation before
		# removing it.
		if [[ "$installed" == remove ]]; then
			echo "Do you want to create a backup of the current"
			echo -n "$installed_name installation? [y/n] "
			choice && installed=backup
		fi
	fi

	# User wants an overwrite.
	[[ -z "$installed" ]] && installed=overwrite

	# What to do.
	case $installed in
		(leave)		error "$installed_name already installed" ;;

		(remove)	pkgrm --force "$package" ;;

		(backup)	pkgrm --backup --force "$package" &&
				backed_up=yes ;;

		(overwrite)	log_warning "overwriting $installed_name"
	esac
}

# Usage: init_install
# Prepare install_log if necessary.
function init_install {
	if [[ "$log_install" == yes ]]; then
		if [[ -e "$timestamp" ]]; then

			# install-log timestamp doubles as a lock so only one
			# installation may occur at once.  Otherwise install-log
			# will confuse installed files between packages.
			warning "install-log appears to already be in use"
			error "if not, delete \`$timestamp' and try again"
		else

			# Create timestamp.
			touch --reference="$directory" "$timestamp"
		fi
	fi
}

# Usage: finish_install
# If necessary, install $profile into $profiles, & run install-log.
function finish_install {

	# Install profile if not already in $profiles.
	if [[ "$profile" != "$profiles/$package.pkg" ]]; then
		install -m644 "$profile" "$profiles" ||
		warning "could not install profile \`$profile' in \`$profiles'"
	fi

	# Run install-log & clean up.
	if [[ "$log_install" == yes ]];
		if install-log --force "$package"; then
			add_version_entry "$version"
		else
			error "running install-log failed"
		fi

		# Release lock.
		rm "$timestamp" || error "releasing lock failed"
	fi
}

# Usage: cleanup_failed
# Uninstall any files installed by a failed installation.
function cleanup_failed {

	# $failed wasn't set on the command line.  Go interactive.
	if [[ -z "$failed" ]]; then
		echo "Do you want clean up the failed installation of"
		echo -n "$name? [y/n] "
		choice && failed=remove
	fi

	[[ "$failed" == remove ]] && pkgrm --force "$package" &&

	# Did we backup a previous install?  If so, restore it & related
	# install-log files.
	# FIXME: pkgrm should include install-log log in tarball.  Then use
	#	 unpack to restore backup.
	if [[ "$backed_up" == yes ]]; then
		echo "Restoring backup of $installed_name..."
		tar xvjf "$backupdir/$package.bak.tar.bz2" > \
			 "$logdir/$package" ||
		failure "restoring backup failed"

		add_version_entry "$installed_version"
	fi
}

# --------------------------- START EXECUTION HERE --------------------------- #

unset backed_up failed installed installed_name installed_version package_list

# Check for options.
while [[ "$1" == -* ]]; do
	case "$1" in
		(-b|--backup-installed)		installed=backup ;;

		(-c|--config)			config="$2"
						shift ;;

		(--config=*)			config="${1#--config=}" ;;

		(-h|-\?|--help)			usage ;;

		(-l|--leave-installed)		installed=leave ;;

		(-L|--leave-failed)		failed=leave ;;

		(-o|--overwrite-installed)	installed=overwrite ;;

		(-r|--remove-installed)		installed=remove ;;

		(-R|--remove-failed)		failed=remove ;;

		(-s|--stage)			set_stage "$2"
						shift ;;

		(--stage=*)			set_stage "${1#--stage=}" ;;

		(-V|--version)			version ;;

		(--)				shift
						break ;;

		(*)		script_usage_err "unrecognized option: \`$1'"
	esac
	shift
done

# The remaining arguments should all be packages.
(( $# == 0 )) && script_usage_err "no packages to install"

# Remove duplicate packages from parameter list.
package_list=( "$@" )
remove_dupes package_list

source_config

# If there is more than one package, install each in its own instance.
if (( ${#package_list[@]} > 1 )); then
	for package in "${package_list[@]}"; do
		"$0" --config="$config" ${installed:+--$installed-installed} \
		     ${failed:+--$failed-failed} --stage=$stage "$package" ||
		error "installation of \`$package' failed"
	done
	finish
fi

# There is only one package to install.  Do so in this instance.
profiles_cwd=yes
open_package "${package_list[0]}"

# Check we know how to install package.
if is_func install_pkg; then

	# Ensure we the have necessary privileges, (optionally) remove any
	# existing installation of $package & initialize install-log.
	get_privileges
	remove_installed
	init_install

	# Run the install commands from the package's profile. finish_install
	# must be run even if we fail, so capture the return value for later.
	cd "$directory" || error "cannot enter \`$directory'"
	log install_pkg
	declare -i retval=$?

	# Run install-log.
	finish_install

	# Clean up if the install failed.
	if (( retval != 0 )); then
		failure "installation of $name_ver failed"
		cleanup_failed
	fi

else

	# No commands for installing package!
	warning "no install_pkg function in \`$profile'"
	error "cannot install $name_ver"
fi

finish
